## 其它计算机相关知识

[1.[2021-3-9] UTF-8 和 Unicode 有什么联系？](https://github.com/HJY-xh/plantTrees/issues/52)

<details>
<summary>展开查看</summary>
<pre>
UTF-8就是在互联网上使用最广的一种unicode的实现方式。
Unicode的出现是为了统一地区性文字编码方案，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。
ASCII --> 地区性编码（GBK） --> Unicode --> UTF-8
</pre>
</details>

[2.[2021-3-18] CDN 是什么？](https://github.com/HJY-xh/plantTrees/issues/66)

<details>
<summary>展开查看</summary>
<pre>

CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。

</pre>
</details>

[3.[2021-3-24] Base64 是什么？](https://github.com/HJY-xh/plantTrees/issues/81)

<details>
<summary>展开查看</summary>
<pre>
Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。

Base64 的原理很简单，首先，准备一个包含 64 个字符的数组：

```javascript
["A", "B", "C", ..."a", "b", "c", ..."0", "1", ..."+", "/"]; //A-Za-z0-9+/
```

然后，对二进制数据进行处理，每 3 个字节一组，一共是 3x8=24bit，划为 4 组，每组正好 6 个 bit。

这样就可以得到 4 个数字作为索引，然后查表，获得相应的 4 个字符，就是编码后的字符串。

所以，Base64 编码会把 3 字节的二进制数据编码为 4 字节的文本数据，长度增加 33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。

如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？Base64 用\x00 字节在末尾补足后，再在编码的末尾加上 1 个或 2 个=号，表示补了多少字节，解码的时候，会自动去掉。

</pre>
</details>

[4.[2021-3-28] 什么是 XSS？](https://github.com/HJY-xh/plantTrees/issues/91)

<details>
<summary>展开查看</summary>
<pre>

`XSS`，即 Cross Site Script，中译是跨站脚本攻击。

其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS 攻击可以分为 3 类：反射型（非持久型）、存储型（持久型）、基于 DOM。

</pre>
</details>

[5.[2021-3-28] xss 类型有哪些？](https://github.com/HJY-xh/plantTrees/issues/92)

<details>
<summary>展开查看</summary>
<pre>

-   反射型 （Reflected XSS ） 发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。

-   存储型存 Stored XSS 和 Reflected XSS 的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。

-   DOM 型 （DOM-based or local XSS） 即基于 DOM 或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。可以通过 DOM 来动态修改页面内容，从客户端获取 DOM 中的数据并在本地执行。基于这个特性，就可以利用 JS 脚本来实现 XSS 漏洞的利用。

实际情况下的攻击例子：

反射型 XSS：拼接 url 获取用户敏感数据
假如一个接口`http://www.test.com/xss/reflect.php`的代码如下:

```php
<?php
echo 'x'
>
```

这里的 x 值没有经过处理直接输出,当客户端提交请求`http://www.test.com/xss/reflect.php?x=<script>alert(1)</script>`，此时浏览器会触发 alert()函数。

存储型 XSS：最典型的例子就是留言板 XSS,当用户提交了一条包含 XSS 代码的留言存储到数据库,目标用户查看留言板时,留言内容会从数据库提取并展示在页面上,浏览器发现有 XSS 代码,就当成 HTML 和 JavaScript 解析执行,从而触发 XSS 攻击.简单的可以是一个 alert()弹窗,复杂一些的可以是盗用用户 cookie 等操作。

DOM XSS：举例有这样一个网站，可以让你对某个文章输入评论：

```javascript
eval("alert('Hello world')");
```

</pre>
</details>

[6.[2021-3-30] 前端开发中有哪些内存泄露的情况？](https://github.com/HJY-xh/plantTrees/issues/101)

<details>
<summary>展开查看</summary>
<pre>

概念：内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

可能造成的原因：

-   全局变量
-   DOM 清空时，还存在引用
-   不规范地使用闭包
-   定时器未清理
-   子元素存在引起的内存泄露

避免策略：

-   减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收(即赋值为 null)；
-   注意程序逻辑，避免“死循环”之类的 ；
-   避免创建过多的对象 原则：不用了的东西要记得及时归还。
-   减少层级过多的引用

</pre>
</details>

[7.[2021-4-3] CSRF 攻击攻击原理是什么？](https://github.com/HJY-xh/plantTrees/issues/115)

<details>
<summary>展开查看</summary>
<pre>

`CSRF` , 即 Cross-site request forgery）中文译为跨站请求伪造，是伪造请求，冒充用户在站内的正常操作。

我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

</pre>
</details>

[8.[2021-4-3] CSRF 攻击攻击过程是什么样的？](https://github.com/HJY-xh/plantTrees/issues/116)

<details>
<summary>展开查看</summary>
<pre>

举个例子：

Web A 为存在 CSRF 漏洞的网站，Web B 为攻击者构建的恶意网站，User C 为 Web A 网站的合法用户。

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
2. 在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

</pre>
</details>

[9.[2021-4-3] 如何防范 CSRF?](https://github.com/HJY-xh/plantTrees/issues/117)

<details>
<summary>展开查看</summary>
<pre>

-   验证 HTTP `Referer` 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer 记录了该 HTTP 请求的来源地址。

    -   优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。
    -   缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。

-   在请求地址中添加`token`并验证。CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

    -   优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。
    -   缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。

-   在 HTTP 头中自定义属性并验证。 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

    -   优点：统一管理 token 输入输出，可以保证 token 的安全性。
    -   缺点：有局限性，无法在非异步的请求上实施。

</pre>
</details>

[10.[2021-4-4] SPA 单页应用的优缺点是什么？](https://github.com/HJY-xh/plantTrees/issues/118)

<details>
<summary>展开查看</summary>
<pre>

SPA（single-page application）仅在 web 页面初始化时加载相应的 HTML、JavaScript 和 CSS，一旦页面就自爱完成，spa 不会因为用户的操作而进行页面的重新加载或跳转，而是利用路由机制 实现 HTML 内容的变换，可以避免页面的重新加载。

优点：

-   用户体验好、快。内容改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染
-   SPA 相对于服务器压力小
-   前后端分离，架构清晰，前端负责交互逻辑，后端负责数据处理

缺点：

-   首屏（初次）加载慢：为实现 SPA 页面，需要将加载页面的时候将 JavaScript 和 CSS 统一加载，部分页面按需加载；
-   不利于 SEO：由于所有的内容都在一个页面中动态替换展示，所以 SEO 上有天然的弱势

</pre>
</details>

[11.[2021-4-10] 如何开启 DNS 预解析？](https://github.com/HJY-xh/plantTrees/issues/132)

<details>
<summary>展开查看</summary>
<pre>

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
（强制打开a标签的DNS预解析，https下默认关闭）
<link rel="dns-prefetch" href="//host_name_to_prefetch.com" />
```

</pre>
</details>

[12.[2021-4-10] 为什么要预解析 DNS？](https://github.com/HJY-xh/plantTrees/issues/133)

<details>
<summary>展开查看</summary>
<pre>

DNS 预解析会消耗前端的性能，因此减少 DNS 的请求次数，进行 DNS 预解析，从而减少用户的等待时间，就能提升用户体验。

</pre>
</details>

[13.[2021-4-15] PWA 是什么？](https://github.com/HJY-xh/plantTrees/issues/151)

<details>
<summary>展开查看</summary>
<pre>

PWA（Progressive Web App）渐进式网页应用，目的是提升 Web App 的性能，改善 Web App 的用户体验。

在 2014 年， W3C 公布过 Service Worker 的相关草案，但是其在生产环境被 Chrome 支持是在 2015 年。因此，如果把 PWA 的关键技术之一 Service Worker 的出现作为 PWA 的诞生时间，那就应该是 2015 年。

自 2015 年以来，PWA 相关的技术不断升级优化，在用户体验和用户留存两方面都提供了非常好的解决方案。PWA 可以将 Web 和 App 各自的优势融合在一起：渐进式、可响应、可离线、实现类似 App 的交互、即时更新、安全、可以被搜索引擎检索、可推送、可安装、可链接。

需要特别说明的是，PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push，等等。

</pre>
</details>

[14.[2021-4-16] PWA 和 Native App、Web App 相比有什么优势？](https://github.com/HJY-xh/plantTrees/issues/153)

<details>
<summary>展开查看</summary>
<pre>

Native APP 用起来很流畅，且以可靠而且丰富的功能而著称，但是也有其天然的基因缺陷：

-   由于其天生封闭的基因，内容无法被索引
-   用户 80% 的时间被 Top3 的超级 App 占据，对于站点来说，应用分发的性价比也越来越不划算
-   要使用它，首先还需要先下载几十兆上百兆的安装包

Web App 虽然天生具有开放的基因，但是很多时候页面会卡顿，用户体验不佳。虽然社区之前也做过很多努力，例如 virtual dom、spa、混合编程、用 canvas 将整个页面画出来，用户体验也有了很大的改善，但是仍然无法解决几个重要的问题：

-   离线时用户无法使用
-   无法接收消息推送
-   移动端没有一级入口

W3C 和谷歌看到了这些问题，于是推出了 PWA。因此 PWA 的核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。媲美 native 的流畅体验，将网络之长与应用之长相结合。

再来看看 PWA 具备哪些特性：

-   快速
    快速响应，用平滑的动画响应用户的操作
-   可靠
    即使在不稳定的网络环境下，也能瞬间加载并展现，并且可以实现离线使用。为了实现这个目标，PWA 使用了一项新的技术：`Service Worker`，这项技术可以实现前端直接处理网络请求，起到类似于中转服务器的作用，同时由于 `Service Worker` 是独立线程，执行过程对于页面性能影响很小，可以同时保障主线程的流畅执行。
-   可安装/沉浸式体验
    它是指可以像原生 APP 在主屏幕上留有图标，不过这需要我们提供`Web app manifest`，manifest.json 是一个简单的 JSON 文件，它描述了我们的图标在主屏幕上如何显示，以及图标点击进去的启动页是什么。

</pre>
</details>

[15.[2021-4-17] require 和 import 有什么不同?](https://github.com/HJY-xh/plantTrees/issues/156)

<details>
<summary>展开查看</summary>
<pre>

require/exports 是运行时动态加载，import/export 是静态编译

CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。- 阮一峰

</pre>
</details>

[16.[2021-4-18] hosts 文件有什么作用？](https://github.com/HJY-xh/plantTrees/issues/157)

<details>
<summary>展开查看</summary>
<pre>

hosts 文件是个没有扩展名的系统文件，其作用就是将网址域名和其对应的 IP 地址建立一个关联“数据库”，当用户在浏览器中输入一个 url 时，系统会首先自动从 hosts 文件中寻找对应的 IP 地址。

</pre>
</details>

[17.[2021-4-20] Flux 核心思想是什么？](https://github.com/HJY-xh/plantTrees/issues/162)

<details>
<summary>展开查看</summary>
<pre>

简单说，Flux 是一种架构思想，专门解决软件的结构问题。它跟 MVC 架构是同一类东西，但是更加简单和清晰。

Flux 的最大特点，就是数据的"单向流动"。

1.用户访问 View

2.View 发出用户的 Action

3.Dispatcher 收到 Action，要求 Store 进行相应的更新

4.Store 更新后，发出一个"change"事件

5.View 收到"change"事件后，更新页面

</pre>
</details>

[18.[2021-4-20] webP 是什么？](https://github.com/HJY-xh/plantTrees/issues/166)

<details>
<summary>展开查看</summary>
<pre>

WebP 是谷歌开发的一种新图片格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用 webP 格式的最大优点是是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减少，这样会提高用户的体验。这是谷歌开发的一种新的图片格式。

那如何判断浏览器是否支持 webP 呢？

可以通过创建 Image 对象，将其 src 属性设置为 webP 格式的图片，然后在 onload 事件中获取图片的宽高，如果能够获取，则说明浏览器支持 webP 格式图片。如果不能获取或者触发了 onerror 函数，那么就说明浏览器不支持 webp 格式的图片。

</pre>
</details>

[19.[2021-4-22] RESTful 架构中的幂等性体现在哪里？](https://github.com/HJY-xh/plantTrees/issues/172)

<details>
<summary>展开查看</summary>
<pre>

先来了解什么是幂等性？

幂等性概念：幂等通俗来说是指不管进行多少次重复操作，都是实现相同的结果。

那 REST 请求中哪些是幂等操作呢？

GET，PUT，DELETE 都是幂等操作，而 POST 不是。

首先 GET 请求很好理解，对资源做查询多次，此实现的结果都是一样的。

PUT 请求的幂等性可以这样理解，将 A 修改为 B，它第一次请求值变为了 B，再进行多次此操作，最终的结果还是 B，与一次执行的结果是一样的，所以 PUT 是幂等操作。

同理可以理解 DELETE 操作，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。

POST 不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此 POST 不是幂等操作。

</pre>
</details>

[20.[2021-4-23] SCRUM 是什么?](https://github.com/HJY-xh/plantTrees/issues/174)

<details>
<summary>展开查看</summary>
<pre>

Scrum 是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。

在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个 Sprint，每个 Sprint 的建议长度是一至四周。

在 Scrum 中，使用产品 Backlog 来管理产品的需求，产品 backlog 是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事。Scrum 团队总是先开发对客户具有较高价值的需求。在 Sprint 中，Scrum 团队从产品 Backlog 中挑选最高优先级的需求进行开发。挑选的需求在 Sprint 计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为 Sprint backlog。

在每个迭代结束时，Scrum 团队将递交潜在可交付的产品增量。 Scrum 起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。

</pre>
</details>

[21.[2021-4-24] 前端需要注意哪些 SEO？](https://github.com/HJY-xh/plantTrees/issues/178)

<details>
<summary>展开查看</summary>
<pre>

-   合理的`title`、`description`、`keywords`

搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；

keywords 列举出重要关键词即可

-   语义化的 HTML 代码，符合 W3C 规范

语义化代码让搜索引擎容易理解网页

-重要内容 HTML 代码放在最前

搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取

-   非装饰性图片加 alt 属性
-   提高网站速度

网站速度是搜索引擎排序的一个重要指标

</pre>
</details>

[22.[2021-4-25] XML 和 JSON 有什么区别？](https://github.com/HJY-xh/plantTrees/issues/180)

<details>
<summary>展开查看</summary>
<pre>

-   数据体积方面：JSON 相对于 XML 来说，数据体积更小
-   数据交互方面：JSON 与 JavaScript 交互更方便，更容易解析
-   数据描述方面：JSON 对数据的描述性比 XML 差
-   数据传输方面：JSON 传递速度更快

</pre>
</details>

[23.[2021-4-26] SQL 注入原理及防范措施有哪些？](https://github.com/HJY-xh/plantTrees/issues/184)

<details>
<summary>展开查看</summary>
<pre>

SQL 注入原理：通过把 SQL 命令插入到 Web 表单提交或调用接口时的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。

防范措施：

-   永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
-   永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。
-   永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
-   不要把机密信息明文存放，请加密或者 hash 密码和敏感的信息。

</pre>
</details>

[24.[2021-4-30] 衬线字体是什么？](https://github.com/HJY-xh/plantTrees/issues/202)

<details>
<summary>展开查看</summary>
<pre>

西方国家字母体系分为两类：衬线字体（serif）以及无衬线体（sans serif）。

-   衬线字体，意思是在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同
-   无衬线体是无衬线字体，没有这些额外的装饰，而且笔画的粗细差不多

衬线字体容易识别，它强调了每个字母笔画的开始和结束，因此易读性比较高，无衬线体则比较醒目。在整文阅读的情况下，适合使用衬线字体进行排版，易于换行阅读的识别性，避免发生行间的阅读错误。

西文中，无衬线体强调每一个字母，衬线字体更强调于一个单词。

中文字体中的宋体就是一种最标准的衬线字体，衬线的特征非常明显。字形结构也和手写的楷书一致。因此宋体一直被做为最适合的正文字体。

</pre>
</details>

[25.[2021-5-7] 如何理解前端模块化？](https://github.com/HJY-xh/plantTrees/issues/222)

<details>
<summary>展开查看</summary>
<pre>

前端模块化就是复杂的文件编成一个一个独自的模块，比如 JS 文件等等。简单点说就是把一段代码封装起来，便于重复使用。分成独立的模块有利于重用和维护。这样会引来模块之间相互依赖的问题，所以有了 commonJS 规范、AMD、CMD 规范等等。

举个例子 🌰：

es5 之前没有模块化，使用 commonJs 的规范

使用**module.exports**导出，用**require+path**引入

```javascript
module.exports = {
	name: "nobody",
	funA: function () {
		return `我是${this.name}`;
	},
};

require("./example.js");
```

ES6 之后的模块化分为**导出（export）**与**导入（import）**

```javascript
export { some };
```

```javascript
import { some } from "./example.js";
```

注意：vue 与 react 也都是使用组件的形式开发，也相当于模块化；微信小程序中的组件也使用了模块化。

</pre>
</details>

[26.[2021-5-9] 堆和栈有什么区别？](https://github.com/HJY-xh/plantTrees/issues/226)

<details>
<summary>展开查看</summary>
<pre>

-   空间分配区别

栈（操作系统）：由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。

-   缓存方式区别

栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得慢一些。

-   数据结构区别

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

栈（数据结构）：一种先进后出的数据结构。

</pre>
</details>

[27.[2021-5-5] 手机浏览器和 PC 浏览器的区别？](https://github.com/HJY-xh/plantTrees/issues/211)

<details>
<summary>展开查看</summary>
<pre>

提完问题去找答案的时候发现这个问题太大了，找不到准确的问题和准确的答案。看到一些回答说手机浏览器的`架构`、`协议`、`硬件`、`分辨率`、`频率`不一样。作为前端开发者，**不能用理论解释移动浏览器的兼容 BUG**，有一些可能是浏览器的缺陷导致的。解决方案只能去 google 之。

尽管主流的网站做法是 PC 和 M 使用两套 DOM，但是不排除小型前端项目有 pc 和 M 共用的基础组件。所以有一些需要注意的问题：(仅踩坑 📝）

**1. 关于自适应**

手机浏览器没有 window 对象，所以不能监听 window 的宽度，想实现页面的`自适应`可以用媒体查询。

**2. 关于视口与 meta 标签的作用**

对于 pc 端，有一个叫`初始包含块`的东西。body 设置一个宽度设置的 100%，浏览器的可是窗口和布局视图是一致的。

但是在 M 端，需要设置 meta 标签属性，以使两者一致：

```html
<meta name="viewport" content="width=device-idth,initial-scale=1" />
```

参考文档：
[web 前端--移动端适配总结](https://www.cnblogs.com/webspace/p/8625464.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E9%80%89%E6%8B%A9)

</pre>
</details>

[28.[2021-4-28] 前端反爬虫策略？](https://github.com/HJY-xh/plantTrees/issues/194)

<details>
<summary>展开查看</summary>
<pre>

1、 FONT-FACE 拼凑式

例子：猫眼电影

猫眼电影里，对于票房数据，展示的并不是纯粹的数字。

页面使用了 font-face 定义了字符集，并通过 unicode 去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。

并且，每次刷新页面，字符集的 url 都是有变化的，无疑更大难度地增加了爬取成本。

2、 BACKGROUND 拼凑式

例子：美团

与 font 的策略类似，美团里用到的是 background 拼凑。数字其实是图片，根据不同的 background 偏移，显示出不同的字符。

并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成 0-9 与小数点。

3、 字符穿插式

某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。

这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。

4、 伪元素隐藏式

例子：汽车之家

汽车之家里，把关键的厂商信息，做到了伪元素的 content 里。

这也是一种思路：爬取网页，必须得解析 css，需要拿到伪元素的 content，这就提升了爬虫的难度。

5、 元素定位覆盖式

例子：去哪儿

还有热爱数学的去哪儿，对于一个 4 位数字的机票价格，先用四个 i 标签渲染，再用两个 b 标签去绝对定位偏移量，覆盖故意展示错误的 i 标签，最后在视觉上形成正确的价格…

这说明爬虫会解析 css 还不行，还得会做数学题。

6、 IFRAME 异步加载式

例子：网易云音乐

网易云音乐页面一打开，html 源码里几乎只有一个 iframe，并且它的 src 是空白的：about:blank。接着 js 开始运行，把整个页面的框架异步塞到了 iframe 里面…

不过这个方式带来的难度并不大，只是在异步与 iframe 处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用 selenium 还是 phantom，都有 API 可以拿到 iframe 里面的 content 信息。

7、 字符分割式

例子：全网代理 IP

在一些展示代理 IP 信息的页面，对于 IP 的保护也是大费周折。

他们会先把 IP 的数字与符号分割成 dom 节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。

8、字符集替换式

例子：去哪儿移动侧

同样会欺骗爬虫的还有去哪儿的移动版。

html 里明明写的 3211，视觉上展示的却是 1233。原来他们重新定义了字符集，3 与 1 的顺序刚好调换得来的结果。

</pre>
</details>

[29.[2021-5-11] 虚拟机是什么？](https://github.com/HJY-xh/plantTrees/issues/231)

<details>
<summary>展开查看</summary>
<pre>

## 什么是虚拟机

虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。

在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。

## 为什么要使用虚拟机

服务器整合是使用虚拟机的首要原因。部署到裸机时，大多数操作系统和应用部署都只会使用少量的物理资源。通过虚拟化服务器，可以在每个物理服务器上设置大量虚拟服务器，从而提高硬件利用率。

## 原理

虚拟化技术允许多个虚拟环境共享一个系统。虚拟机监控程序负责管理硬件并将物理资源与虚拟环境分隔开。来自物理环境的资源根据需要进行分区后，会分配给虚拟机使用。

虚拟机运行时，当用户或程序发出需要从物理环境获取更多资源的指令，虚拟机监控程序会调度物理系统的资源请求，以便虚拟机的操作系统和应用可以访问共享的物理资源池。

</pre>
</details>

[30.[2021-5-18] Web 开发中代理的含义是什么？](https://github.com/HJY-xh/plantTrees/issues/251)

<details>
<summary>展开查看</summary>
<pre>

代理是在服务器和客户端之间假设的一层服务器，比如说正向代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。

不管是正向代理还是反向代理，实现的都是上面的功能。

> 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。

正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。

正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。

> 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。

反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。

</pre>
</details>

[31.[2021-5-20] 懒加载的概念?](https://github.com/HJY-xh/plantTrees/issues/255)

<details>
<summary>展开查看</summary>
<pre>

懒加载也叫延迟加载、按需加载，一般指在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或者应用中，如果图片很多，所有图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。

如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。

</pre>
</details>

[32.[2021-5-21] Nginx 的概念及其工作原理是什么？](https://github.com/HJY-xh/plantTrees/issues/257)

<details>
<summary>展开查看</summary>
<pre>

Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。

传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于 event-driven 模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。

Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和 Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的 HTTP 请求，而每个 Apache process 只能处理一个。

</pre>
</details>

[33.[2021-6-1] 什么是中间人攻击？](https://github.com/HJY-xh/plantTrees/issues/273)

<details>
<summary>展开查看</summary>
<pre>

中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们他们正在通过一个私密的的连接与对方直接通话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新内容。

过程如下：

-   客户端请求发送到服务端，被中间人截获
-   服务器向客户端发送公钥
-   中间人截获公钥并保留，同时生成伪造的公钥发送给客户端
-   客户端收到伪造的公钥后，生成加密 hash 值发送给服务器
-   中间人获得加密 hash 值，用自己的私钥解密获得真秘钥，同时生成假的加密 hash 值发送给服务器
-   服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端

</pre>
</details>

[34.[2021-6-5] CDN 的使用场景有哪些？](https://github.com/HJY-xh/plantTrees/issues/284)

<details>
<summary>展开查看</summary>
<pre>

-   使用第三方的 CDN 服务：如果想要开源一些项目，可以使用第三方 CDN 服务
-   使用 CDN 进行静态资源的缓存：将自己网站的静态资源放在 CDN 上，比如 Js、CSS、图片等等，也可以将整个项目放在 CDN 上，完成一键部署。
-   直播传送：直播本质上是使用流媒体进行传送的，所以直播完全可以使用 CDN 来提高访问速度。CDN 在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就回去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。

</pre>
</details>

[35.[2021-6-8] CPU 和 GPU 的区别和作用是什么？](https://github.com/HJY-xh/plantTrees/issues/290)

<details>
<summary>展开查看</summary>
<pre>

-   CPU（Central Processing Unit）

它是计算机的大脑。CPU 是计算机里面的一块芯片，上面有一个或者多个核心（core）。我们可以把 CPU 的一个核心（core）比喻成一个办公室工人，他功能强大，上知天文下知地理，琴棋书画无所不能，它可以串行地一件接着一件处理交给它的任务。很久之前的时候大多数 CPU 只有一个核心，不过在现在的硬件设备上 CPU 通常会有多个核心，因为多核心 CPU 可以大大提高手机和电脑的运算能力。

-   GPU（Graphics Processing Unit）图形处理器

它是计算机的另外一个重要组成部分。和功能强大的 CPU 核心不一样的是，单个 GPU 核心只能处理一些简单的任务，不过它胜在数量多，单片 GPU 上会有很多很多的核心可以同时工作，也就是说它的并行计算能力是非常强的。图形处理器（GPU）顾名思义一开始就是专门用来处理图形的，所以在说到图形使用 GPU（using）或者 GPU 支持（backed）时，人们就会联想到图形快速渲染或者流畅的用户体验相关的概念。最近几年来，随着 GPU 加速概念的流行，在 GPU 上单独进行的计算也变得越来越多了。

当我们在手机或者电脑上打开某个应用程序的时候，背后其实是 CPU 和 GPU 支撑着这个应用程序的运行。通常来说，应用要通过操作系统提供的一些机制才能跑在 CPU 和 GPU 上面。

</pre>
</details>

[36.[2021-6-11] API 访问如何鉴权？](https://github.com/HJY-xh/plantTrees/issues/301)

<details>
<summary>展开查看</summary>
<pre>

传统的 Web 站点可以通过登陆来解决用户鉴权问题，而在保障 API 接口的安全性上，需要遵循如下原则：

-   有调用者身份
-   请求具有唯一性
-   请求的参数不能被篡改
-   请求有效时间，即 API 对应的令牌（token）的有效期要长一些

目前流行的鉴权方式有两种：JSON Web Token(JWT)、OAuth

</pre>
</details>

[37.[2021-6-11] OAuth 鉴权流程是什么样的？](https://github.com/HJY-xh/plantTrees/issues/302)

<details>
<summary>展开查看</summary>
<pre>

开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。目前主流版本是 2.0 版本。

![1](https://user-images.githubusercontent.com/39485286/121683069-742c8000-caef-11eb-9d0e-e37f5d857e22.png)

运行步骤如下：

-   用户打开客户端以后，客户端要求用户给予授权
-   用户同意给予客户端授权
-   客户端使用上一步获得的授权，向认证服务器申请令牌
-   认证服务器对客户端进行认证以后，确认无误，同意发放令牌
-   客户端使用令牌，向资源服务器申请获取资源
-   资源服务器确认令牌无误，同意向客户端开放资源

</pre>
</details>

[38.[2021-6-13] 数据结构的基本操作有哪些？](https://github.com/HJY-xh/plantTrees/issues/305)

<details>
<summary>展开查看</summary>
<pre>

对于任何数据结构，其基本操作无非是遍历+访问，再具体一点就是：增、删、查、改。

数据结构种类很多，但它们存在的目的无非就是在不同的应用场景下尽可能高效地增、删、查、改，这也是数据结构的使命。

如何对数据结构进行遍历+访问呢？其实也就是两种形式：线性和非线性。

</pre>
</details>

[39.[2021-6-13] 石器时代：同步](https://github.com/HJY-xh/plantTrees/issues/308)

<details>
<summary>展开查看</summary>
<pre>

最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于耽误的状态。它的处理能力相当低下，假每次响应服务耗用的时间稳定为 N 秒，这类服务的 QPS 为 1/N。

这类架构如今已基本被淘汰，只在一些无并发要求的应用中存在。

</pre>
</details>

[40.[2021-6-14] 青铜时代：复制进程](https://github.com/HJY-xh/plantTrees/issues/309)

<details>
<summary>展开查看</summary>
<pre>

为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即 100 个连接需要启动 100 个进程来进行服务，这是非常昂贵的代价，在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。

为了解决启动缓慢的问题，预复制（prefork）被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽，

假设通过复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为 M，那这类服务的 QPS 为 M/N。

</pre>
</details>

[41.[2021-6-14] 白银时代：多线程](https://github.com/HJY-xh/plantTrees/issues/310)

<details>
<summary>展开查看</summary>
<pre>

为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个 CPU 核心在一个时刻只能做一件事件，操作系统只能通过将 CPU 切分为时间片的方法，让线程可以较为均匀地使用 CPU 资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被被好用再上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。

如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的 1/L，受资源上限的影响，它的 QPS 则为 M\*L/N。

</pre>
</details>

[42.[2021-6-14] 黄金时代：事件驱动](https://github.com/HJY-xh/plantTrees/issues/311)

<details>
<summary>展开查看</summary>
<pre>

多线程的服务模型服役了很长一段时间，Apache 就是采用多线程/多进程模型实现的，当并发增长到上万时，内存耗用的问题将会暴露出来，这即是著名的 C10k 问题。

为了解决高并发问题，基于事件驱动的服务模型出现了，像 Node 和 Nginx 均是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。

基于事件的服务模型存在的问题有两个：

-   如何充分利用多核 CPU 服务器
-   如何保证进程的健壮性和稳定性

单线程的架构并不少见，其中尤以 PHP 最为致命——在 PHP 中没有线程的支持。它的健壮性是由它给每个请求都建立独立的上下文来实现的。但是对于 Node 来说，所有请求的上下文都是统一的，它的稳定性是亟待解决的问题。

由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于 CPU 的计算能力，它的上限决定这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响，可伸缩性远比前两者高。如果解决掉多核 CPU 的利用问题，带来的性能上提升是客观的。

</pre>
</details>

[43.[2021-6-16] 密码存储有哪些手段？](https://github.com/HJY-xh/plantTrees/issues/319)

<details>
<summary>展开查看</summary>
<pre>

常用的如下（从不安全到安全）

-   明文存储
-   哈希存储，例如 MD5、SHA、SHA256
-   加盐哈希存储

如果直接对密码进行哈希存储，那么黑客可以对一个已知密码进行哈希处理，然后通过对比哈希值得到用户的密码。换句话说，虽然黑客不能获取某位特定用户的密码，但他可以知道使用特定密码的用户有哪些。

加盐处理可以在一定程度上解决上述问题。所谓加盐，就是加点”佐料“。其基本思路是这样的：当用户首次提供密码时（通常是在注册时——，由系统自动往这个密码里加一些”佐料“，然后再进行哈希运算。而当用户登录时，系统要在用户输入的代码中加入相同的”佐料“，然后进行哈希运算得到哈希值，再将此哈希值与系统中保存的哈希值做比较，以确定用户输入的密码是否正确。

这里的”佐料“是指”Salt 值“，这个值是由系统随机生成的，并且只有系统知道。几遍两个用户使用了同一个密码，由于系统为它们生成的 Salt 值不同，因此它们的哈希值也是不同的。黑客可以通过密码和生成的哈希值寻找使用特定密码的用户，但这个概率很小，只有它们使用的密码和 Salt 值与用户一样时才行。

</pre>
</details>

[44.[2021-6-17] 强类型语言和弱类型语言的区别？](https://github.com/HJY-xh/plantTrees/issues/321)

<details>
<summary>展开查看</summary>
<pre>

-   强类型语言 强类型语言也被成为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java 和 C++等语言都是强制类型定义的，也就是说，一但一个变量被制定了某个数据类型，如果不经过强制转换，那么它永远是这个数据类型。加入你有一个整数，如果不显示地进行转换，就不能将其视为一个字符串。

-   弱类型语言 弱类型语言也被成为弱类型定义语言，与强类型定义相反。JavaScript 语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如 JavaScript 是弱类型定义的，在 JavaScript 中就可以将字符串‘12’和整数 3 进行连接得到字符串‘123’，在相加的时候会进行强制类型转换。

两者对比：强类型语言在速度上可能略逊于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。

</pre>
</details>

[45.[2021-6-18] DNS 协议是什么?](https://github.com/HJY-xh/plantTrees/issues/323)

<details>
<summary>展开查看</summary>
<pre>

概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。

作用： 将域名解析为 IP 地址，客户端向 DNS 服务器（DNS 服务器有自己的 IP 地址）发送域名查询请求，DNS 服务器告知客户机 Web 服务器的 IP 地址。

</pre>
</details>

[46.[2021-6-19] 什么是二叉查找树？](https://github.com/HJY-xh/plantTrees/issues/325)

<details>
<summary>展开查看</summary>
<pre>

二叉查找树（BST）：

-   左子树上所有节点的值均小等于它的根节点的值
-   右子树上所有节点的值均大灯与它的根节点的值
-   左右子树也分别为二叉查找树

下图中这棵树，就是一颗典型的二叉查找树：

![2](https://user-images.githubusercontent.com/39485286/122633834-33df8a00-d10d-11eb-86d8-08b76b2a9207.png)

</pre>
</details>

[47.[2021-6-21] 怎么样设计一个分页功能？](https://github.com/HJY-xh/plantTrees/issues/327)

<details>
<summary>展开查看</summary>
<pre>

### 何为分页？

在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示 10 条数据
![微信图片_20210621131856](https://user-images.githubusercontent.com/70680781/122710657-53082400-d293-11eb-9afb-4d5fd173a45f.jpg)
要实现分页功能，实际上就是从结果集中显示第 1 至 10 条记录作为第 1 页，显示第 11 至 20 条记录作为第 2 页，以此类推。
**因此，分页实际上就是从结果集中截取出第 M~N 条记录。**

### 如何实现？

前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据：

```c#
{
  "totalCount": 1836,   // 总的条数
  "totalPages": 92,  // 总页数
  "currentPage": 1   // 当前页数
  "data": [     // 当前页的数据
     {
       ...
     }
  ]
}
```

后端采用 `mysql` 作为数据的持久性存储
前端向后端发送目标的页码 **page** 以及每页显示数据的数量 **pageSize**，默认情况每次取 10 条数据，则每一条数据的起始位置 **start** 为：

```javascript
const start = (page - 1) * pageSize;
```

当确定了 **limit** 和 **start** 的值后，就能够确定 `SQL` 语句：

```javascript
const sql = `SELECT * FROM record limit ${pageSize} OFFSET ${start};`;
```

上述 SQL 语句表达的意思为：截取从 **start** 到 **start+pageSize** 之间（左闭右开）的数据
因此后端的处理逻辑为：

-   获取用户参数页码数 page 和每页显示的数目 pageSize ，其中 page 是必须传递的参数，pageSize 为可选参数，默认为 10
-   编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询
-   查询数据库，返回总数据量、总页数、当前页、当前页数据给前端
    **代码于下方评论区给出**

### 总结

通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量 pageSize，然后根据当前页的索引 pageIndex（从 1 开始），确定 LIMIT 和 OFFSET 应该设定的值：

-   LIMIT 总是设定为 pageSize
-   OFFSET 计算公式为 pageSize \* (pageIndex - 1)

确定了这两个值，就能查询出第 **N** 页的数据

</pre>
</details>

[48.[2021-6-22] 前端常见的报错信息有哪些？](https://github.com/HJY-xh/plantTrees/issues/329)

<details>
<summary>展开查看</summary>
<pre>

### ReferenceError

引用类型错误。引用不存在的变量时会报这个错。如:

```javascript
console.log(a);
```

会报错: `Uncaught ReferenceError: a is not defined` 因为 a 被引用时，还没有被定义。

### SyntaxError

语法错误。出现语法错误时会报这个错。如:

```javascript
let c == 5
```

会报错: `Uncaught SyntaxError: Unexpected token '=='`

### TypeError

类型错误。值的类型与预期不一致时会报这个错。如：

```javascript
let data = await fetch("/api/list");
data.list;
```

如果 data 是 **undefined**。会报错：`Uncaught TypeError: Cannot read property 'list' of undefined` 预期是对象，实际是 **undefined**。
再看一个：

```javascript
doSth();
function doSth(cb) {
	cb();
}
```

会报：`Uncaught TypeError: cb is not a function` 预期是函数，实际不是。

### RangeError

范围错误。当设置的数值超出相应的范围会报这个错。如：

```javascript
new Array(-1);
```

会报：`Uncaught RangeError: Invalid array length`

</pre>
</details>

[49.[2021-6-22] PNG 图片有什么特点？](https://github.com/HJY-xh/plantTrees/issues/330)

<details>
<summary>展开查看</summary>
<pre>

PNG 的全称是便携式网络图形（Portable Network Graphics），它是主流的网络传输和展示的图片格式，它具有如下特性:

-   无损压缩：PNG 图片采取了基于 LZ77 派生算法对文件进行压缩，是的它压缩比率更高，生成的文件体积更小，并且不损失数据。
-   体积小：它利用特殊的编码方法标机重复出现的数据，使得同样格式的图片，PNG 图片文件的体积更小。网络通讯中因受带宽制约，在保证图片清晰的前提下，优先选择 PNG 格式的图片。
-   支持透明效果：PNG 图片支持对原图像定义 256 个透明层次，使得图像的边缘能与任何背景平滑融合，这种特性是 GIF 和 JPEG 没有的。

</pre>
</details>

[50.[2021-6-26] 负载均衡是什么？](https://github.com/HJY-xh/plantTrees/issues/346)

<details>
<summary>展开查看</summary>
<pre>

当有了多个服务器时，可以用它们组成服务器集群，这样在用户访问网站时，会先访问到一个中间服务器，这个中间服务器在服务器集群中选择一个负载压力小的服务器，将请求引入选择的服务器。

所以对于用户每次访问，这样都能保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况，这就是负载均衡。

</pre>
</details>

[51.[2021-6-28] CNAME 记录是什么？](https://github.com/HJY-xh/plantTrees/issues/348)

<details>
<summary>展开查看</summary>
<pre>

真是名称记录（Canonical Name Record)，即 CNAME 记录，是域名系统（DNS）的一种记录。

CNAME 记录用于将一个域名（同名）映射到另一个域名（真实名称），域名解析服务器遇到 CNAME 记录会以映射到的目标重新开始查询。

这对于需要在同一个 IP 地址上运行多个服务的情况来说非常方便，若要同时运行文件传输服务和 Web 服务，则可以把 ftp.example.com 和www.example.com都指向DNS记录example.com，而后者则有一个指向IP地址的A记录。如此一来，若服务器IP地址改变，则只需修改example.com的A记录即可。

CNAME 记录必须指向另一个域名，而不能是 IP 地址。

</pre>
</details>
