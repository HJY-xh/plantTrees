## 其它计算机相关知识

[1.[2021-3-9] UTF-8 和 Unicode 有什么联系？](https://github.com/HJY-xh/plantTrees/issues/52)

<details>
<summary>展开查看</summary>
<pre>
UTF-8就是在互联网上使用最广的一种unicode的实现方式。
Unicode的出现是为了统一地区性文字编码方案，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。
ASCII --> 地区性编码（GBK） --> Unicode --> UTF-8
</pre>
</details>

[2.[2021-3-18] CDN 是什么？](https://github.com/HJY-xh/plantTrees/issues/66)

<details>
<summary>展开查看</summary>
<pre>

CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。

</pre>
</details>

[3.[2021-3-24] Base64 是什么？](https://github.com/HJY-xh/plantTrees/issues/81)

<details>
<summary>展开查看</summary>
<pre>
Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。

Base64 的原理很简单，首先，准备一个包含 64 个字符的数组：

```javascript
["A", "B", "C", ..."a", "b", "c", ..."0", "1", ..."+", "/"]; //A-Za-z0-9+/
```

然后，对二进制数据进行处理，每 3 个字节一组，一共是 3x8=24bit，划为 4 组，每组正好 6 个 bit。

这样就可以得到 4 个数字作为索引，然后查表，获得相应的 4 个字符，就是编码后的字符串。

所以，Base64 编码会把 3 字节的二进制数据编码为 4 字节的文本数据，长度增加 33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。

如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？Base64 用\x00 字节在末尾补足后，再在编码的末尾加上 1 个或 2 个=号，表示补了多少字节，解码的时候，会自动去掉。

</pre>
</details>

[4.[2021-3-28] 什么是 XSS？](https://github.com/HJY-xh/plantTrees/issues/91)

<details>
<summary>展开查看</summary>
<pre>

`XSS`，即 Cross Site Script，中译是跨站脚本攻击。

其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS 攻击可以分为 3 类：反射型（非持久型）、存储型（持久型）、基于 DOM。

</pre>
</details>

[5.[2021-3-28] xss 类型有哪些？](https://github.com/HJY-xh/plantTrees/issues/92)

<details>
<summary>展开查看</summary>
<pre>

-   反射型 （Reflected XSS ） 发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。

-   存储型存 Stored XSS 和 Reflected XSS 的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。

-   DOM 型 （DOM-based or local XSS） 即基于 DOM 或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。可以通过 DOM 来动态修改页面内容，从客户端获取 DOM 中的数据并在本地执行。基于这个特性，就可以利用 JS 脚本来实现 XSS 漏洞的利用。

实际情况下的攻击例子：

反射型 XSS：拼接 url 获取用户敏感数据
假如一个接口`http://www.test.com/xss/reflect.php`的代码如下:

```php
<?php
echo 'x'
>
```

这里的 x 值没有经过处理直接输出,当客户端提交请求`http://www.test.com/xss/reflect.php?x=<script>alert(1)</script>`，此时浏览器会触发 alert()函数。

存储型 XSS：最典型的例子就是留言板 XSS,当用户提交了一条包含 XSS 代码的留言存储到数据库,目标用户查看留言板时,留言内容会从数据库提取并展示在页面上,浏览器发现有 XSS 代码,就当成 HTML 和 JavaScript 解析执行,从而触发 XSS 攻击.简单的可以是一个 alert()弹窗,复杂一些的可以是盗用用户 cookie 等操作。

DOM XSS：举例有这样一个网站，可以让你对某个文章输入评论：

```javascript
eval("alert('Hello world')");
```

</pre>
</details>

[6.[2021-3-30] 前端开发中有哪些内存泄露的情况？](https://github.com/HJY-xh/plantTrees/issues/101)

<details>
<summary>展开查看</summary>
<pre>

概念：内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

可能造成的原因：

-   全局变量
-   DOM 清空时，还存在引用
-   不规范地使用闭包
-   定时器未清理
-   子元素存在引起的内存泄露

避免策略：

-   减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收(即赋值为 null)；
-   注意程序逻辑，避免“死循环”之类的 ；
-   避免创建过多的对象 原则：不用了的东西要记得及时归还。
-   减少层级过多的引用

</pre>
</details>

[7.[2021-4-3] CSRF 攻击攻击原理是什么？](https://github.com/HJY-xh/plantTrees/issues/115)

<details>
<summary>展开查看</summary>
<pre>

`CSRF` , 即 Cross-site request forgery）中文译为跨站请求伪造，是伪造请求，冒充用户在站内的正常操作。

我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

</pre>
</details>

[8.[2021-4-3] CSRF 攻击攻击过程是什么样的？](https://github.com/HJY-xh/plantTrees/issues/116)

<details>
<summary>展开查看</summary>
<pre>

举个例子：

Web A 为存在 CSRF 漏洞的网站，Web B 为攻击者构建的恶意网站，User C 为 Web A 网站的合法用户。

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
2. 在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

</pre>
</details>

[9.[2021-4-3] 如何防范 CSRF?](https://github.com/HJY-xh/plantTrees/issues/117)

<details>
<summary>展开查看</summary>
<pre>

-   验证 HTTP `Referer` 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer 记录了该 HTTP 请求的来源地址。

    -   优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。
    -   缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。

-   在请求地址中添加`token`并验证。CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

    -   优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。
    -   缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。

-   在 HTTP 头中自定义属性并验证。 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

    -   优点：统一管理 token 输入输出，可以保证 token 的安全性。
    -   缺点：有局限性，无法在非异步的请求上实施。

</pre>
</details>

[10.[2021-4-4] SPA 单页应用的优缺点是什么？](https://github.com/HJY-xh/plantTrees/issues/118)

<details>
<summary>展开查看</summary>
<pre>

SPA（single-page application）仅在 web 页面初始化时加载相应的 HTML、JavaScript 和 CSS，一旦页面就自爱完成，spa 不会因为用户的操作而进行页面的重新加载或跳转，而是利用路由机制 实现 HTML 内容的变换，可以避免页面的重新加载。

优点：

-   用户体验好、快。内容改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染
-   SPA 相对于服务器压力小
-   前后端分离，架构清晰，前端负责交互逻辑，后端负责数据处理

缺点：

-   首屏（初次）加载慢：为实现 SPA 页面，需要将加载页面的时候将 JavaScript 和 CSS 统一加载，部分页面按需加载；
-   不利于 SEO：由于所有的内容都在一个页面中动态替换展示，所以 SEO 上有天然的弱势

</pre>
</details>

[11.[2021-4-10] 如何开启 DNS 预解析？](https://github.com/HJY-xh/plantTrees/issues/132)

<details>
<summary>展开查看</summary>
<pre>

```html
<meta http-equiv="x-dns-prefetch-control" content="on" />
（强制打开a标签的DNS预解析，https下默认关闭）
<link rel="dns-prefetch" href="//host_name_to_prefetch.com" />
```

</pre>
</details>

[12.[2021-4-10] 为什么要预解析 DNS？](https://github.com/HJY-xh/plantTrees/issues/133)

<details>
<summary>展开查看</summary>
<pre>

DNS 预解析会消耗前端的性能，因此减少 DNS 的请求次数，进行 DNS 预解析，从而减少用户的等待时间，就能提升用户体验。

</pre>
</details>

[13.[2021-4-15] PWA 是什么？](https://github.com/HJY-xh/plantTrees/issues/151)

<details>
<summary>展开查看</summary>
<pre>

PWA（Progressive Web App）渐进式网页应用，目的是提升 Web App 的性能，改善 Web App 的用户体验。

在 2014 年， W3C 公布过 Service Worker 的相关草案，但是其在生产环境被 Chrome 支持是在 2015 年。因此，如果把 PWA 的关键技术之一 Service Worker 的出现作为 PWA 的诞生时间，那就应该是 2015 年。

自 2015 年以来，PWA 相关的技术不断升级优化，在用户体验和用户留存两方面都提供了非常好的解决方案。PWA 可以将 Web 和 App 各自的优势融合在一起：渐进式、可响应、可离线、实现类似 App 的交互、即时更新、安全、可以被搜索引擎检索、可推送、可安装、可链接。

需要特别说明的是，PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push，等等。

</pre>
</details>

[14.[2021-4-16] PWA 和 Native App、Web App 相比有什么优势？](https://github.com/HJY-xh/plantTrees/issues/153)

<details>
<summary>展开查看</summary>
<pre>

Native APP 用起来很流畅，且以可靠而且丰富的功能而著称，但是也有其天然的基因缺陷：

-   由于其天生封闭的基因，内容无法被索引
-   用户 80% 的时间被 Top3 的超级 App 占据，对于站点来说，应用分发的性价比也越来越不划算
-   要使用它，首先还需要先下载几十兆上百兆的安装包

Web App 虽然天生具有开放的基因，但是很多时候页面会卡顿，用户体验不佳。虽然社区之前也做过很多努力，例如 virtual dom、spa、混合编程、用 canvas 将整个页面画出来，用户体验也有了很大的改善，但是仍然无法解决几个重要的问题：

-   离线时用户无法使用
-   无法接收消息推送
-   移动端没有一级入口

W3C 和谷歌看到了这些问题，于是推出了 PWA。因此 PWA 的核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。媲美 native 的流畅体验，将网络之长与应用之长相结合。

再来看看 PWA 具备哪些特性：

-   快速
    快速响应，用平滑的动画响应用户的操作
-   可靠
    即使在不稳定的网络环境下，也能瞬间加载并展现，并且可以实现离线使用。为了实现这个目标，PWA 使用了一项新的技术：`Service Worker`，这项技术可以实现前端直接处理网络请求，起到类似于中转服务器的作用，同时由于 `Service Worker` 是独立线程，执行过程对于页面性能影响很小，可以同时保障主线程的流畅执行。
-   可安装/沉浸式体验
    它是指可以像原生 APP 在主屏幕上留有图标，不过这需要我们提供`Web app manifest`，manifest.json 是一个简单的 JSON 文件，它描述了我们的图标在主屏幕上如何显示，以及图标点击进去的启动页是什么。

</pre>
</details>

[15.[2021-4-17] require 和 import 有什么不同?](https://github.com/HJY-xh/plantTrees/issues/156)

<details>
<summary>展开查看</summary>
<pre>

require/exports 是运行时动态加载，import/export 是静态编译

CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。- 阮一峰

</pre>
</details>

[16.[2021-4-18] hosts 文件有什么作用？](https://github.com/HJY-xh/plantTrees/issues/157)

<details>
<summary>展开查看</summary>
<pre>

hosts 文件是个没有扩展名的系统文件，其作用就是将网址域名和其对应的 IP 地址建立一个关联“数据库”，当用户在浏览器中输入一个 url 时，系统会首先自动从 hosts 文件中寻找对应的 IP 地址。

</pre>
</details>

[17.[2021-4-20] Flux 核心思想是什么？](https://github.com/HJY-xh/plantTrees/issues/162)

<details>
<summary>展开查看</summary>
<pre>

简单说，Flux 是一种架构思想，专门解决软件的结构问题。它跟 MVC 架构是同一类东西，但是更加简单和清晰。

Flux 的最大特点，就是数据的"单向流动"。

1.用户访问 View

2.View 发出用户的 Action

3.Dispatcher 收到 Action，要求 Store 进行相应的更新

4.Store 更新后，发出一个"change"事件

5.View 收到"change"事件后，更新页面

</pre>
</details>

[18.[2021-4-20] webP 是什么？](https://github.com/HJY-xh/plantTrees/issues/166)

<details>
<summary>展开查看</summary>
<pre>

WebP 是谷歌开发的一种新图片格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用 webP 格式的最大优点是是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减少，这样会提高用户的体验。这是谷歌开发的一种新的图片格式。

那如何判断浏览器是否支持 webP 呢？

可以通过创建 Image 对象，将其 src 属性设置为 webP 格式的图片，然后在 onload 事件中获取图片的宽高，如果能够获取，则说明浏览器支持 webP 格式图片。如果不能获取或者触发了 onerror 函数，那么就说明浏览器不支持 webp 格式的图片。

</pre>
</details>

[19.[2021-4-22] RESTful 架构中的幂等性体现在哪里？](https://github.com/HJY-xh/plantTrees/issues/172)

<details>
<summary>展开查看</summary>
<pre>

先来了解什么是幂等性？

幂等性概念：幂等通俗来说是指不管进行多少次重复操作，都是实现相同的结果。

那 REST 请求中哪些是幂等操作呢？

GET，PUT，DELETE 都是幂等操作，而 POST 不是。

首先 GET 请求很好理解，对资源做查询多次，此实现的结果都是一样的。

PUT 请求的幂等性可以这样理解，将 A 修改为 B，它第一次请求值变为了 B，再进行多次此操作，最终的结果还是 B，与一次执行的结果是一样的，所以 PUT 是幂等操作。

同理可以理解 DELETE 操作，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。

POST 不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此 POST 不是幂等操作。

</pre>
</details>

[20.[2021-4-23] SCRUM 是什么?](https://github.com/HJY-xh/plantTrees/issues/174)

<details>
<summary>展开查看</summary>
<pre>

Scrum 是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。

在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个 Sprint，每个 Sprint 的建议长度是一至四周。

在 Scrum 中，使用产品 Backlog 来管理产品的需求，产品 backlog 是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事。Scrum 团队总是先开发对客户具有较高价值的需求。在 Sprint 中，Scrum 团队从产品 Backlog 中挑选最高优先级的需求进行开发。挑选的需求在 Sprint 计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为 Sprint backlog。

在每个迭代结束时，Scrum 团队将递交潜在可交付的产品增量。 Scrum 起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。

</pre>
</details>

[21.[2021-4-24] 前端需要注意哪些 SEO？](https://github.com/HJY-xh/plantTrees/issues/178)

<details>
<summary>展开查看</summary>
<pre>

-   合理的`title`、`description`、`keywords`

搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；

keywords 列举出重要关键词即可

-   语义化的 HTML 代码，符合 W3C 规范

语义化代码让搜索引擎容易理解网页

-重要内容 HTML 代码放在最前

搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取

-   非装饰性图片加 alt 属性
-   提高网站速度

网站速度是搜索引擎排序的一个重要指标

</pre>
</details>

[22.[2021-4-25] XML 和 JSON 有什么区别？](https://github.com/HJY-xh/plantTrees/issues/180)

<details>
<summary>展开查看</summary>
<pre>

-   数据体积方面：JSON 相对于 XML 来说，数据体积更小
-   数据交互方面：JSON 与 JavaScript 交互更方便，更容易解析
-   数据描述方面：JSON 对数据的描述性比 XML 差
-   数据传输方面：JSON 传递速度更快

</pre>
</details>

[23.[2021-4-26] SQL 注入原理及防范措施有哪些？](https://github.com/HJY-xh/plantTrees/issues/184)

<details>
<summary>展开查看</summary>
<pre>

SQL 注入原理：通过把 SQL 命令插入到 Web 表单提交或调用接口时的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。

防范措施：

-   永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
-   永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。
-   永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
-   不要把机密信息明文存放，请加密或者 hash 密码和敏感的信息。

</pre>
</details>

[24.[2021-4-30] 衬线字体是什么？](https://github.com/HJY-xh/plantTrees/issues/202)

<details>
<summary>展开查看</summary>
<pre>

西方国家字母体系分为两类：衬线字体（serif）以及无衬线体（sans serif）。

-   衬线字体，意思是在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同
-   无衬线体是无衬线字体，没有这些额外的装饰，而且笔画的粗细差不多

衬线字体容易识别，它强调了每个字母笔画的开始和结束，因此易读性比较高，无衬线体则比较醒目。在整文阅读的情况下，适合使用衬线字体进行排版，易于换行阅读的识别性，避免发生行间的阅读错误。

西文中，无衬线体强调每一个字母，衬线字体更强调于一个单词。

中文字体中的宋体就是一种最标准的衬线字体，衬线的特征非常明显。字形结构也和手写的楷书一致。因此宋体一直被做为最适合的正文字体。

</pre>
</details>

[25.[2021-5-7] 如何理解前端模块化？](https://github.com/HJY-xh/plantTrees/issues/222)

<details>
<summary>展开查看</summary>
<pre>

前端模块化就是复杂的文件编成一个一个独自的模块，比如 JS 文件等等。简单点说就是把一段代码封装起来，便于重复使用。分成独立的模块有利于重用和维护。这样会引来模块之间相互依赖的问题，所以有了 commonJS 规范、AMD、CMD 规范等等。

举个例子 🌰：

es5 之前没有模块化，使用 commonJs 的规范

使用**module.exports**导出，用**require+path**引入

```
    module.exports = {
          name: "nobody",
          funA: function(){
             return `我是${this.name}`
          }
    }


    require('./example.js')
```

ES6 之后的模块化分为**导出（export）**与**导入（import）**

```
    export {some}
```

```
    import {some} from "./example.js"
```

注意：vue 与 react 也都是使用组件的形式开发，也相当于模块化；微信小程序中的组件也使用了模块化。

</pre>
</details>

[26.[2021-5-9] 堆和栈有什么区别？](https://github.com/HJY-xh/plantTrees/issues/226)

<details>
<summary>展开查看</summary>
<pre>

-   空间分配区别

栈（操作系统）：由操作系统（编译器）自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。

-   缓存方式区别

栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得慢一些。

-   数据结构区别

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

栈（数据结构）：一种先进后出的数据结构。

</pre>
</details>

[27.[2021-5-5] 手机浏览器和 PC 浏览器的区别？](https://github.com/HJY-xh/plantTrees/issues/211)

<details>
<summary>展开查看</summary>
<pre>

提完问题去找答案的时候发现这个问题太大了，找不到准确的问题和准确的答案。看到一些回答说手机浏览器的`架构`、`协议`、`硬件`、`分辨率`、`频率`不一样。作为前端开发者，**不能用理论解释移动浏览器的兼容 BUG**，有一些可能是浏览器的缺陷导致的。解决方案只能去 google 之。

尽管主流的网站做法是 PC 和 M 使用两套 DOM，但是不排除小型前端项目有 pc 和 M 共用的基础组件。所以有一些需要注意的问题：(仅踩坑 📝）

**1. 关于自适应**

手机浏览器没有 window 对象，所以不能监听 window 的宽度，想实现页面的`自适应`可以用媒体查询。

**2. 关于视口与 meta 标签的作用**

对于 pc 端，有一个叫`初始包含块`的东西。body 设置一个宽度设置的 100%，浏览器的可是窗口和布局视图是一致的。

但是在 M 端，需要设置 meta 标签属性，以使两者一致：

    <meta name="viewport" content="width=device-idth,initial-scale=1">

参考文档：
[web 前端--移动端适配总结](https://www.cnblogs.com/webspace/p/8625464.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E9%80%89%E6%8B%A9)

</pre>
</details>
