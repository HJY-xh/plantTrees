## 其它计算机相关知识

[1.[2021-3-9] UTF-8 和 Unicode 有什么联系？](https://github.com/HJY-xh/plantTrees/issues/52)

<details>
<summary>展开查看</summary>
<pre>
UTF-8就是在互联网上使用最广的一种unicode的实现方式。
Unicode的出现是为了统一地区性文字编码方案，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。
ASCII --> 地区性编码（GBK） --> Unicode --> UTF-8
</pre>
</details>

[2.[2021-3-18] CDN 是什么？](https://github.com/HJY-xh/plantTrees/issues/66)

<details>
<summary>展开查看</summary>
<pre>

CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。

</pre>
</details>

[3.[2021-3-24] Base64 是什么？](https://github.com/HJY-xh/plantTrees/issues/81)

<details>
<summary>展开查看</summary>
<pre>
Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。

Base64 的原理很简单，首先，准备一个包含 64 个字符的数组：

```javascript
["A", "B", "C", ..."a", "b", "c", ..."0", "1", ..."+", "/"]; //A-Za-z0-9+/
```

然后，对二进制数据进行处理，每 3 个字节一组，一共是 3x8=24bit，划为 4 组，每组正好 6 个 bit。

这样就可以得到 4 个数字作为索引，然后查表，获得相应的 4 个字符，就是编码后的字符串。

所以，Base64 编码会把 3 字节的二进制数据编码为 4 字节的文本数据，长度增加 33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。

如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？Base64 用\x00 字节在末尾补足后，再在编码的末尾加上 1 个或 2 个=号，表示补了多少字节，解码的时候，会自动去掉。

</pre>
</details>

[4.[2021-3-28] 什么是 XSS？](https://github.com/HJY-xh/plantTrees/issues/91)

<details>
<summary>展开查看</summary>
<pre>

`XSS`，即 Cross Site Script，中译是跨站脚本攻击。

其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS 攻击可以分为 3 类：反射型（非持久型）、存储型（持久型）、基于 DOM。

</pre>
</details>

[5.[2021-3-28] xss 类型有哪些？](https://github.com/HJY-xh/plantTrees/issues/92)

<details>
<summary>展开查看</summary>
<pre>

-   反射型 （Reflected XSS ） 发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。

-   存储型存 Stored XSS 和 Reflected XSS 的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。

-   DOM 型 （DOM-based or local XSS） 即基于 DOM 或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。可以通过 DOM 来动态修改页面内容，从客户端获取 DOM 中的数据并在本地执行。基于这个特性，就可以利用 JS 脚本来实现 XSS 漏洞的利用。

实际情况下的攻击例子：

反射型 XSS：拼接 url 获取用户敏感数据
假如一个接口`http://www.test.com/xss/reflect.php`的代码如下:

```php
<?php
echo 'x'
>
```

这里的 x 值没有经过处理直接输出,当客户端提交请求`http://www.test.com/xss/reflect.php?x=<script>alert(1)</script>`，此时浏览器会触发 alert()函数。

存储型 XSS：最典型的例子就是留言板 XSS,当用户提交了一条包含 XSS 代码的留言存储到数据库,目标用户查看留言板时,留言内容会从数据库提取并展示在页面上,浏览器发现有 XSS 代码,就当成 HTML 和 JavaScript 解析执行,从而触发 XSS 攻击.简单的可以是一个 alert()弹窗,复杂一些的可以是盗用用户 cookie 等操作。

DOM XSS：举例有这样一个网站，可以让你对某个文章输入评论：

```javascript
eval("alert('Hello world')");
```

</pre>
</details>

[6.[2021-3-30] 前端开发中有哪些内存泄露的情况？](https://github.com/HJY-xh/plantTrees/issues/101)

<details>
<summary>展开查看</summary>
<pre>

概念：内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

可能造成的原因：

-   全局变量
-   DOM 清空时，还存在引用
-   不规范地使用闭包
-   定时器未清理
-   子元素存在引起的内存泄露

避免策略：

-   减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收(即赋值为 null)；
-   注意程序逻辑，避免“死循环”之类的 ；
-   避免创建过多的对象 原则：不用了的东西要记得及时归还。
-   减少层级过多的引用

</pre>
</details>

[7.[2021-4-3] CSRF 攻击攻击原理是什么？](https://github.com/HJY-xh/plantTrees/issues/115)

<details>
<summary>展开查看</summary>
<pre>

`CSRF` , 即 Cross-site request forgery）中文译为跨站请求伪造，是伪造请求，冒充用户在站内的正常操作。

我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

</pre>
</details>

[8.[2021-4-3] CSRF 攻击攻击过程是什么样的？](https://github.com/HJY-xh/plantTrees/issues/116)

<details>
<summary>展开查看</summary>
<pre>

举个例子：

Web A 为存在 CSRF 漏洞的网站，Web B 为攻击者构建的恶意网站，User C 为 Web A 网站的合法用户。

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
2. 在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

</pre>
</details>

[9.[2021-4-3] 如何防范 CSRF](https://github.com/HJY-xh/plantTrees/issues/117)

<details>
<summary>展开查看</summary>
<pre>

-   验证 HTTP `Referer` 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer 记录了该 HTTP 请求的来源地址。

    -   优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。
    -   缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。

-   在请求地址中添加`token`并验证。CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

    -   优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。
    -   缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。

-   在 HTTP 头中自定义属性并验证。 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

    -   优点：统一管理 token 输入输出，可以保证 token 的安全性。
    -   缺点：有局限性，无法在非异步的请求上实施。

</pre>
</details>
